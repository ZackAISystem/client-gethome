<script>
(function () {
  // =========================================================
  // GetHome Search Engine (NO fetch, NO layout changes)
  // Works with:
  // - data/search/dict.json
  // - data/search/search_index.json
  // - data/search/area_aliases.json
  // Listens:
  // - search:set {q}
  // - search:updated {q}
  // - search:clear
  // =========================================================

  const LANGS = ["en","ru","ar","hi"];
  const STORAGE_KEY = "results_query";

  function getLang(){
    const l = (document.documentElement.getAttribute("lang") || "en").toLowerCase();
    return LANGS.includes(l) ? l : "en";
  }

  // --- embed DICT + INDEX + AREA_ALIASES from Hugo data (no fetch!) ---
  let DICT = {{ site.Data.search.dict | jsonify }};
  if (typeof DICT === "string") { try { DICT = JSON.parse(DICT); } catch(e){ DICT = {}; } }

  let INDEX = {{ site.Data.search.search_index | jsonify }};
  if (typeof INDEX === "string") { try { INDEX = JSON.parse(INDEX); } catch(e){ INDEX = {}; } }

  let AREA_ALIASES = {{ site.Data.search.area_aliases | jsonify }};
  if (typeof AREA_ALIASES === "string") { try { AREA_ALIASES = JSON.parse(AREA_ALIASES); } catch(e){ AREA_ALIASES = {}; } }

  const projectsIndex = Array.isArray(INDEX && INDEX.projects) ? INDEX.projects : [];

  // Build fast lookup by slug
  const bySlug = new Map();
  for (const p of projectsIndex) {
    if (p && p.slug) bySlug.set(String(p.slug), p);
  }

  // --- helpers: normalize text keys (area/emirate compare) ---
  function normKey(s){
    return String(s || "")
      .toLowerCase()
      .trim()
      .replace(/[_\-]+/g, " ")
      .replace(/\s+/g, " ");
  }

  // --- build area alias lookup: any variant -> canonical area ---
  // Supports AREA_ALIASES formats:
  // 1) { areas: [ { key, labels, aliases:{en/ru/ar/hi:[]}, ... } ] }
  // 2) legacy: { "zabeel": ["zabeel 1", ...], ... }
  const areaByVariant = new Map();

  (function buildAreaMap(){
    if (!AREA_ALIASES || typeof AREA_ALIASES !== "object") return;

    // Format 1: { areas: [...] }
    const list = Array.isArray(AREA_ALIASES.areas) ? AREA_ALIASES.areas : null;
    if (list) {
      for (const a of list) {
        if (!a) continue;

        const canonical = normKey(a.key || "");
        if (!canonical) continue;

        // canonical maps to itself
        areaByVariant.set(canonical, canonical);

        // include labels in all languages
        if (a.labels && typeof a.labels === "object") {
          for (const k of Object.keys(a.labels)) {
            const vv = normKey(a.labels[k]);
            if (vv) areaByVariant.set(vv, canonical);
          }
        }

        // include aliases by language
        if (a.aliases && typeof a.aliases === "object") {
          for (const k of Object.keys(a.aliases)) {
            const arr = a.aliases[k];
            if (!Array.isArray(arr)) continue;
            for (const v of arr) {
              const vv = normKey(v);
              if (vv) areaByVariant.set(vv, canonical);
            }
          }
        }
      }
      return;
    }

    // Format 2 (legacy)
    for (const canonicalRaw of Object.keys(AREA_ALIASES)) {
      const canonical = normKey(canonicalRaw);
      if (!canonical) continue;

      areaByVariant.set(canonical, canonical);

      const arr = AREA_ALIASES[canonicalRaw];
      if (Array.isArray(arr)) {
        for (const v of arr) {
          const vv = normKey(v);
          if (vv) areaByVariant.set(vv, canonical);
        }
      }
    }
  })();

  // --- normalizer (stopwords + synonyms) ---
  function buildNormalizer(dict, lang){
    const stop = new Set([
      ...(dict.stopwords?.en || []),
      ...(dict.stopwords?.[lang] || [])
    ].map(x => String(x).toLowerCase()));

    const map = new Map();

    function addBlock(block){
      if (!block) return;
      for (const canonical of Object.keys(block)) {
        map.set(canonical.toLowerCase(), canonical.toLowerCase());
        for (const v of block[canonical]) map.set(String(v).toLowerCase(), canonical.toLowerCase());
      }
    }

    addBlock(dict.synonyms?.global);
    addBlock(dict.synonyms?.[lang]);

    function tokenize(q){
      return String(q || "")
        .toLowerCase()
        .replace(/[^\p{L}\p{N}\s\-]/gu, " ")
        .replace(/\s+/g, " ")
        .trim()
        .split(" ")
        .filter(Boolean);
    }

    function normalize(q){
      const raw = tokenize(q);
      const filtered = raw.filter(tok => !stop.has(tok));

      // glue: "1 br" -> "1br"
      const glued = [];
      for (let i=0; i<filtered.length; i++){
        const a = filtered[i];
        const b = filtered[i+1];
        if (/^[0-9]$/.test(a) && (b === "br" || b === "bedroom" || b === "bedrooms")) {
          glued.push(a + "br");
          i++;
          continue;
        }
        glued.push(a);
      }

      return glued.map(tok => map.get(tok) || tok);
    }

    return { normalize, tokenize };
  }

  // --- DOM helpers (do not change markup) ---
  function getResultsRoot(){ return document.getElementById("results"); }
  function getResultsInput(){ return document.getElementById("resultsQuery"); }

  // ✅ NEW: hero input getter (for sync)
  function getHeroInput(){
    // must match your home input class
    return document.querySelector(".home-hero__input");
  }

  function getCards(){
    const root = getResultsRoot();
    if (!root) return [];
    return Array.from(root.querySelectorAll("a.results-card"));
  }

  function extractSlugFromHref(href){
    try {
      const url = new URL(href, window.location.origin);
      const parts = url.pathname.split("/").filter(Boolean);
      const i = parts.indexOf("projects");
      if (i >= 0 && parts[i+1]) return parts[i+1];
      return parts[parts.length - 1] || "";
    } catch(e) {
      return "";
    }
  }

  // --- Emirate canonicalization (multi-language) ---
  const EMIRATE_CANON = {
    // EN
    "dubai": "dubai",
    "abu dhabi": "abu-dhabi",
    "abudhabi": "abu-dhabi",
    "sharjah": "sharjah",
    "ras al khaimah": "ras-al-khaimah",
    "rasalkhaimah": "ras-al-khaimah",

    // RU
    "дубай": "dubai",
    "абу даби": "abu-dhabi",
    "абудаби": "abu-dhabi",
    "шарджа": "sharjah",
    "рас-эль-хайма": "ras-al-khaimah",
    "рас эль хайма": "ras-al-khaimah",
    "расэльхайма": "ras-al-khaimah",

    // AR
    "دبي": "dubai",
    "أبوظبي": "abu-dhabi",
    "ابوظبي": "abu-dhabi",
    "الشارقة": "sharjah",
    "رأس الخيمة": "ras-al-khaimah",
    "راس الخيمة": "ras-al-khaimah",

    // HI
    "दुबई": "dubai",
    "अबू धाबी": "abu-dhabi",
    "शारजाह": "sharjah",
    "रास अल खैमाह": "ras-al-khaimah"
  };

  const EMIRATE_SET = new Set(["dubai","abu-dhabi","sharjah","ras-al-khaimah"]);

  function canonEmirateFromText(txt){
  const s = String(txt || "")
    .toLowerCase()
    .trim()
    // ВАЖНО: все дефисы/тире/неразрывные дефисы -> пробел
    .replace(/[\u2010\u2011\u2012\u2013\u2014\u2212\-]+/g, " ")
    .replace(/\s+/g, " ");
  return EMIRATE_CANON[s] || "";
}

  function detectEmiratesFromTokens(tokens){
    const out = new Set();

    for (const t of tokens) {
      const c = canonEmirateFromText(t);
      if (c) out.add(c);
    }

    for (let i=0; i<tokens.length-1; i++){
      const bi = (tokens[i] + " " + tokens[i+1]).trim();
      const c = canonEmirateFromText(bi);
      if (c) out.add(c);
    }

    for (let i=0; i<tokens.length-2; i++){
      const tri = (tokens[i] + " " + tokens[i+1] + " " + tokens[i+2]).trim();
      const c = canonEmirateFromText(tri);
      if (c) out.add(c);
    }

    return Array.from(out);
  }

  // ✅ FIX: remove emirate tokens even when emirate is multi-word (abu + dhabi)
  function stripEmirateTokens(tokens){
    const t = (tokens || []).map(x => String(x || "").toLowerCase());
    const used = new Array(t.length).fill(false);

    // prefer longer matches first
    for (let i=0; i<t.length; i++){
      if (i+2 < t.length){
        const tri = (t[i] + " " + t[i+1] + " " + t[i+2]).trim();
        if (canonEmirateFromText(tri)) { used[i]=used[i+1]=used[i+2]=true; continue; }
      }
      if (i+1 < t.length){
        const bi = (t[i] + " " + t[i+1]).trim();
        if (canonEmirateFromText(bi)) { used[i]=used[i+1]=true; continue; }
      }
      if (canonEmirateFromText(t[i])) used[i]=true;
    }

    const out = [];
    for (let i=0; i<t.length; i++){
      if (!used[i]) out.push(t[i]);
    }
    return out;
  }

  function projectHasEmirate(p, canon){
    if (!p || !canon) return false;

    const direct = (p.emirate || p._emirate || "").toString().toLowerCase();
    if (direct) {
      const d = direct.replace(/\s+/g,"-");
      if (d === canon) return true;
    }

    const ptokens = Array.isArray(p.tokens) ? p.tokens.map(x => String(x).toLowerCase()) : [];

    const c1 = canon;
    const c2 = canon.replace(/-/g, " ");
    const c3 = canon.replace(/-/g, "");
    const c4 = canon.replace(/-/g, "_");

    return ptokens.includes(c1) || ptokens.includes(c2) || ptokens.includes(c3) || ptokens.includes(c4);
  }

  // --- Areas detection ---
  function canonAreaFromText(txt){
    const key = normKey(txt);
    return areaByVariant.get(key) || "";
  }

  function detectAreasFromTokens(tokens){
    const out = new Set();

    for (const t of tokens) {
      const c = canonAreaFromText(t);
      if (c) out.add(c);
    }

    for (let n=2; n<=4; n++){
      for (let i=0; i<=tokens.length-n; i++){
        const gram = tokens.slice(i, i+n).join(" ");
        const c = canonAreaFromText(gram);
        if (c) out.add(c);
      }
    }

    return Array.from(out);
  }

  function projectHasArea(p, areaCanon){
    if (!p || !areaCanon) return false;

    const a = normKey(p.area || p._area || "");
    if (a && a === areaCanon) return true;

    const ptokens = Array.isArray(p.tokens) ? p.tokens.map(x => normKey(x)) : [];

    if (ptokens.includes(areaCanon)) return true;

    for (const t of ptokens) {
      const c = areaByVariant.get(t);
      if (c && c === areaCanon) return true;
    }

    return false;
  }

  // =========================================================
  // Budget parsing + price helpers (NEW, soft)  ✅ Variant A
  // =========================================================

  function normalizeBudgetString(raw){
    let s = String(raw || "").toLowerCase();

    // unify separators/spaces
    s = s.replace(/\u00A0/g, " ");           // nbsp
    s = s.replace(/[–—]/g, "-");             // en/em dash -> hyphen
    s = s.replace(/\s+/g, " ").trim();

    // currency noise
    s = s.replace(/(aed|dh|dhs|dirham|dirhams|درهم|د\.إ)/g, " ");

    // RU units -> latin
    // "2м", "2 млн", "2млн" => "2m"
    s = s
      .replace(/(\d)\s*(млн\.?|миллион(?:ов)?|million(?:s)?)/g, "$1m")
      .replace(/(\d)\s*(тыс\.?|тысяч(?:и)?|thousand(?:s)?)/g, "$1k");

    // Cyrillic suffix letters stuck to number: "2м" / "900к"
    s = s.replace(/(\d)\s*м\b/g, "$1m");
    s = s.replace(/(\d)\s*к\b/g, "$1k");

    // also allow "2 м" / "900 к"
    s = s.replace(/(\d)\s+м\b/g, "$1m");
    s = s.replace(/(\d)\s+к\b/g, "$1k");

    // collapse spaces again
    s = s.replace(/\s+/g, " ").trim();
    return s;
  }

  function parseNumberTokenToAED(raw){
    let s = normalizeBudgetString(raw);

    // pick last number+suffix chunk
    const m = s.match(/([0-9][0-9\s.,]*)\s*([km])?$/i);
    if (!m) return null;

    let num = (m[1] || "").replace(/\s+/g, "");
    const hasComma = num.includes(",");
    const hasDot = num.includes(".");

    // tolerate "2,100,000" / "2 100 000" / "2.1" etc
    if (hasComma && hasDot) {
      num = num.replace(/,/g, "");
    } else if (hasComma && !hasDot) {
      const parts = num.split(",");
      if (parts.length === 2 && parts[1].length <= 2) num = parts[0] + "." + parts[1];
      else num = num.replace(/,/g, "");
    } else if (!hasComma && hasDot) {
      const parts = num.split(".");
      if (parts.length > 2) num = parts.join("");
    }

    const value = parseFloat(num);
    if (!isFinite(value)) return null;

    const suffix = (m[2] || "").toLowerCase();
    const mult = suffix === "k" ? 1e3 : (suffix === "m" ? 1e6 : 1);

    return Math.round(value * mult);
  }

  function parseBudgetFromQuery(rawQuery){
    const q0 = String(rawQuery || "");
    if (!/[0-9]/.test(q0)) return null;

    const s = normalizeBudgetString(q0);

    // диапазон: "1m-2m", "1.2m to 2m", "1m до 2m", "1m по 2m"
    let m = s.match(/([0-9][0-9\s.,]*\s*[km]?)\s*(?:-|to|до|по)\s*([0-9][0-9\s.,]*\s*[km]?)/i);
    if (m) {
      const a = parseNumberTokenToAED(m[1]);
      const b = parseNumberTokenToAED(m[2]);
      if (a != null && b != null) return { currency: "aed", min: Math.min(a,b), max: Math.max(a,b) };
    }

    // max / under  ✅ + HI
    m = s.match(/(?:under|below|up to|<=|до|не более|макс(?:\.|)|حتى|بحد أقصى|से कम|तक|अधिकतम)\s*([0-9][0-9\s.,]*\s*[km]?)/i);
    if (m) {
      const x = parseNumberTokenToAED(m[1]);
      if (x != null) return { currency: "aed", min: null, max: x };
    }

    // min / over  ✅ + HI
    m = s.match(/(?:over|above|more than|from|>=|от|свыше|не менее|ابتداء من|من|से शुरू|से ज्यादा|से अधिक)\s*([0-9][0-9\s.,]*\s*[km]?)/i);
    if (m) {
      const x = parseNumberTokenToAED(m[1]);
      if (x != null) return { currency: "aed", min: x, max: null };
    }

    // ВАЖНО: одиночное "2m" без "от/до" сознательно игнорим (меньше ложных срабатываний)
    return null;
  }

  function getProjectPriceAED(p){
    if (!p) return null;

    const candidates = [
      p.price_aed,
      p.price_from_aed,
      p.price_min_aed,
      p.price_from,
      p.price_min,
      p.price,
      p.starting_price_aed,
      p.starting_price
    ];

    for (const c of candidates) {
      if (c == null) continue;

      if (typeof c === "number" && isFinite(c) && c > 0) return Math.round(c);

      const s = String(c).trim();
      if (!s) continue;

      // take first numeric chunk
      const m = s.match(/([0-9][0-9\s.,]*\s*[km]?)/i);
      if (m) {
        const v = parseNumberTokenToAED(m[1]);
        if (v != null) return v;
      }
    }

    return null;
  }

  const STRONG_TOKEN_SET = new Set([
    "apartment","villa","penthouse","townhouse","duplex",
    "0br","1br","2br","3br","4br","5br","6br","7br","8br","9br"
  ]);

  function splitQueryToParts(q, lang){
    const normalizer = buildNormalizer(DICT, lang);
    const tokens = normalizer.normalize(q).map(x => String(x).toLowerCase());

    const emirsFromWhole = canonEmirateFromText(q) ? [canonEmirateFromText(q)] : [];
    const emirsFromTokens = detectEmiratesFromTokens(tokens);

    const fromBullets = String(q || "")
      .split(/[\u00B7•,|/]+/g)
      .map(s => s.trim())
      .filter(Boolean);

    const emirsFromBullets = fromBullets
      .map(s => canonEmirateFromText(s))
      .filter(Boolean);

    const areasFromBullets = fromBullets
      .map(s => canonAreaFromText(s))
      .filter(Boolean);

    const areasFromTokens = detectAreasFromTokens(tokens);

    const emiratesWanted = Array.from(new Set([...emirsFromWhole, ...emirsFromTokens, ...emirsFromBullets]))
      .filter(e => EMIRATE_SET.has(e));

    const areasWanted = Array.from(new Set([...areasFromBullets, ...areasFromTokens]));

    const nonEmirTokens = tokens.filter(t => !EMIRATE_SET.has(t));

    const strong = nonEmirTokens.filter(t => STRONG_TOKEN_SET.has(t));
    const weak   = nonEmirTokens.filter(t => !STRONG_TOKEN_SET.has(t));

    // ✅ Variant A: budget parsed from RAW query (soft)
    const budget = parseBudgetFromQuery(q);

    return { emiratesWanted, areasWanted, strong, weak, tokens, budget };
  }

  function applyFilter(q){
    const root = getResultsRoot();
    if (!root) return;

    const query = String(q || "").trim();
    const cards = getCards();

    if (!query) {
      for (const a of cards) a.style.display = "";
      return;
    }

    const lang = getLang();
    const parts = splitQueryToParts(query, lang);

    const emiratesWanted = parts.emiratesWanted;
    const areasWanted = parts.areasWanted;
    const required = parts.strong;
    const budget = parts.budget;

    // if user typed something, but we detected nothing meaningful -> show all
    if (!emiratesWanted.length && !areasWanted.length && !required.length && !parts.weak.length && !budget) {
      for (const a of cards) a.style.display = "";
      return;
    }

    let matchedIndexedCount = 0;

    // geo-only pools
    const emirPool = [];
    const areaPool = [];

    // candidates for smart fallback
    const candidates = []; // { a, hits, inAreaPool, inEmirPool }

    for (const a of cards) {
      const slug = extractSlugFromHref(a.getAttribute("href") || "");
      const p = bySlug.get(slug);

      // strict mode: if query exists and project not in index -> hide
      if (!p) { a.style.display = "none"; continue; }

      const ptokens = Array.isArray(p.tokens) ? p.tokens.map(x => String(x).toLowerCase()) : [];

      // soft score: how many strong tokens matched
      let hits = 0;
      if (required.length) {
        for (const r of required) if (ptokens.includes(r)) hits++;
      }

      // 1) Emirate gate (OR)
      let inEmir = true;
      if (emiratesWanted.length) {
        inEmir = false;
        for (const e of emiratesWanted) {
          if (projectHasEmirate(p, e)) { inEmir = true; break; }
        }
        if (!inEmir) { a.style.display = "none"; continue; }
        emirPool.push(a);
      }

      // 2) Area gate (OR)
      let inArea = true;
      if (areasWanted.length) {
        inArea = false;
        for (const ar of areasWanted) {
          if (projectHasArea(p, ar)) { inArea = true; break; }
        }
        if (!inArea) { a.style.display = "none"; continue; }
        areaPool.push(a);
      }

      // 2.5) Budget gate (SOFT)
      // - if price exists -> strict filter
      // - if price missing -> do not hide (unless query is budget-only)
      if (budget) {
        const price = getProjectPriceAED(p);

        const hasOtherSignals =
          (emiratesWanted.length || areasWanted.length || required.length || parts.weak.length);

        // budget-only query: if no price -> hide (avoid trash)
        if (price == null && !hasOtherSignals) { a.style.display = "none"; continue; }

        // price exists -> enforce min/max
        if (price != null) {
          if (budget.min != null && price < budget.min) { a.style.display = "none"; continue; }
          if (budget.max != null && price > budget.max) { a.style.display = "none"; continue; }
        }
      }

      // store for fallback ranking (only if passed geo gates)
      candidates.push({
        a,
        hits,
        inAreaPool: areasWanted.length ? inArea : false,
        inEmirPool: emiratesWanted.length ? inEmir : false
      });

      // 3) strong AND gate (strict primary behavior)
      let ok = true;
      for (const r of required) {
        if (!ptokens.includes(r)) { ok = false; break; }
      }
      if (!ok) { a.style.display = "none"; continue; }

      a.style.display = "";
      matchedIndexedCount++;
    }

    // If strict matches exist -> keep old behavior
    if (matchedIndexedCount > 0) return;

    // ------------------------------
    // SMART FALLBACK (soft ranking)
    // ------------------------------

    // hide all first
    for (const a of cards) a.style.display = "none";

    function showSorted(list){
      // list: [{a,hits}]
      list.sort((x, y) => (y.hits - x.hits));

      const hasAnyHit = list.some(x => x.hits > 0);

      if (hasAnyHit) {
        for (const item of list) {
          if (item.hits > 0) item.a.style.display = "";
        }
        return;
      }

      // no hits at all -> show all (avoid empty UX)
      for (const item of list) item.a.style.display = "";
    }

    // Priority: area > emirate > global
    if (areasWanted.length) {
      const list = candidates
        .filter(x => x.inAreaPool)
        .map(x => ({ a: x.a, hits: x.hits }));
      showSorted(list);
      return;
    }

    if (emiratesWanted.length) {
      const list = candidates
        .filter(x => x.inEmirPool)
        .map(x => ({ a: x.a, hits: x.hits }));
      showSorted(list);
      return;
    }

    // no geo -> global soft fallback
    showSorted(candidates.map(x => ({ a: x.a, hits: x.hits })));
  }

  function readSavedQuery(){
    try { return (localStorage.getItem(STORAGE_KEY) || "").trim(); } catch(e){ return ""; }
  }

  function writeSavedQuery(v){
    const s = String(v || "").trim();
    try {
      if (s) localStorage.setItem(STORAGE_KEY, s);
      else localStorage.removeItem(STORAGE_KEY);
    } catch(e){}
  }

  function parseEmiratesFromQueryText(q){
    const parts = String(q || "")
      .split(/[\u00B7•,|/]+/g)
      .map(s => s.trim())
      .filter(Boolean);

    const out = [];
    for (const p of parts) {
      const c = canonEmirateFromText(p);
      if (c) out.push(c);
    }
    return out;
  }

  function rebuildCanonQuery(emiratesCanon, keepText){
    const base = Array.from(new Set(emiratesCanon)).join(" · ");
    const tail = String(keepText || "").trim();
    if (!tail) return base;
    if (!base) return tail;
    return (tail + " · " + base).trim();
  }

  window.addEventListener("search:set", function(e){
    const q = (e.detail && e.detail.q) ? String(e.detail.q) : "";
    applyFilter(q);
  });

  window.addEventListener("search:updated", function(e){
    const q = (e && e.detail && typeof e.detail.q !== "undefined")
      ? String(e.detail.q)
      : (getResultsInput() ? (getResultsInput().value || "") : "");
    applyFilter(q);
  });

  window.addEventListener("search:clear", function(){
    applyFilter("");
  });

  // =========================
  // ✅ NEW: INPUT SYNC (hero <-> results <-> localStorage)
  // =========================

  function setInputValue(el, v){
    if (!el) return;
    const s = String(v || "");
    if (el.value !== s) el.value = s;
  }

  function dispatchSearchSet(q){
    try {
      window.dispatchEvent(new CustomEvent("search:set", { detail: { q: String(q || "") } }));
    } catch(e){}
  }

  let syncTimer = null;

  function syncFromAnySource(rawText){
  const raw = String(rawText || "");      // то, что в инпуте (НЕ трогаем)
  const canon = raw.trim();               // то, чем фильтруем и сохраняем

  // сохраняем КАНОН (без хвостовых пробелов)
  writeSavedQuery(canon);

  // в инпуты кладём RAW (чтобы пробел печатался нормально)
  setInputValue(getHeroInput(), raw);
  setInputValue(getResultsInput(), raw);

  // фильтрация по КАНОНУ
  clearTimeout(syncTimer);
  syncTimer = setTimeout(() => dispatchSearchSet(canon), 30);
}

  function bindInput(el){
  if (!el) return;
  if (el.__gh_bound) return;
  el.__gh_bound = true;

  el.addEventListener("input", () => syncFromAnySource(el.value), { passive: true });

  el.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      syncFromAnySource(el.value);
    }
  });
}

  // chips (still emirate add-to-set logic; we can switch to radio later)
  document.addEventListener("click", function(ev){
    const btn = ev.target && ev.target.closest ? ev.target.closest(".home-hero__chip") : null;
    if (!btn) return;

    const txt = (btn.textContent || "").trim();
    const emir = canonEmirateFromText(txt);
    if (!emir) return;

    ev.preventDefault();
    ev.stopPropagation();
    if (typeof ev.stopImmediatePropagation === "function") ev.stopImmediatePropagation();

    const heroInput = getHeroInput();
    const rInput = getResultsInput();

    const currentText = heroInput ? (heroInput.value || "") : (rInput ? (rInput.value || "") : readSavedQuery());

    const lang = getLang();
    const normalizer = buildNormalizer(DICT, lang);
    const tokens = normalizer.normalize(currentText);

    const existingEmirs = parseEmiratesFromQueryText(currentText);
    const set = new Set(existingEmirs);
    set.add(emir);

    // ✅ FIX: remove multi-word emirates from typedText (prevents "abu dhabi · Abu Dhabi")
    const typedTokens = stripEmirateTokens(tokens);
    const typedText = typedTokens.join(" ").trim();

    const canonQuery = rebuildCanonQuery(Array.from(set), typedText);

    // ✅ use sync (so both inputs + storage stay identical)
    syncFromAnySource(canonQuery);

    // but keep human-friendly display on both inputs
    const labels = [];
    if (typedText) labels.push(typedText);

    for (const c of Array.from(set)) {
      if (c === emir) {
        labels.push(txt);
      } else {
        if (c === "dubai") labels.push("Dubai");
        if (c === "abu-dhabi") labels.push("Abu Dhabi");
        if (c === "sharjah") labels.push("Sharjah");
        if (c === "ras-al-khaimah") labels.push("Ras Al Khaimah");
      }
    }

    const displayText = labels.join(" · ").trim();
    setInputValue(heroInput, displayText);
    setInputValue(rInput, displayText);
  }, true);

  window.addEventListener("i18n:applied", function(){
    const q = readSavedQuery();
    // keep inputs synced on language re-apply too
    setInputValue(getHeroInput(), q);
    setInputValue(getResultsInput(), q);
    applyFilter(q);

    // ✅ restore scroll after i18n too (if coming back from project page)
    restoreReturnScroll();
  });

  // =========================================================
  // ✅ RETURN TO LIST (save/restore scroll)  <<<< ONLY NEW BLOCK
  // =========================================================

  const RETURN_FLAG_KEY = "gh_return_flag";
  const RETURN_SCROLL_KEY = "gh_return_scroll_y";

  function saveReturnScroll(){
    try {
      sessionStorage.setItem(RETURN_FLAG_KEY, "1");
      sessionStorage.setItem(RETURN_SCROLL_KEY, String(window.scrollY || 0));
    } catch(e){}
  }

  function restoreReturnScroll(){

  let flag = "";
  let y = 0;

  try {
    flag = sessionStorage.getItem(RETURN_FLAG_KEY) || "";
    y = parseInt(sessionStorage.getItem(RETURN_SCROLL_KEY) || "0", 10) || 0;
  } catch(e){}

  if (flag !== "1") return;
  if (!y || y < 50) return;

  // очищаем флаги сразу
  try {
    sessionStorage.removeItem(RETURN_FLAG_KEY);
    sessionStorage.removeItem(RETURN_SCROLL_KEY);
  } catch(e){}

  // даём странице стабилизироваться
  setTimeout(function(){ window.scrollTo(0, y); }, 120);
  setTimeout(function(){ window.scrollTo(0, y); }, 400);
  setTimeout(function(){ window.scrollTo(0, y); }, 900);

  // убираем hash, чтобы браузер больше не вмешивался
  history.replaceState(null, "", window.location.pathname);
}

  // ✅ UPDATED BOOT (stable version)
(function boot(){

  const saved = readSavedQuery();

  // 1. Восстановить строку поиска
  if (saved) {
    setInputValue(getHeroInput(), saved);
    setInputValue(getResultsInput(), saved);
  }

  // 2. Привязать обработчики
  bindInput(getHeroInput());
  bindInput(getResultsInput());

  // 3. Применить фильтр (если есть запрос)
  if (saved) {
  setTimeout(function(){
    applyFilter(saved);
  }, 50);
}

  // 4. Восстановить скролл ТОЛЬКО если реально возвращаемся со страницы проекта
  let returnFlag = "";
  try {
    returnFlag = sessionStorage.getItem(RETURN_FLAG_KEY) || "";
  } catch(e){}

  if (returnFlag === "1") {
    setTimeout(function(){
      restoreReturnScroll();
    }, 400);
  }

})();

})();   // ← закрытие большого IIFE
</script>